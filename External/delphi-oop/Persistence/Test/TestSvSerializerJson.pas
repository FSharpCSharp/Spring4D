unit TestSvSerializerJson;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, SysUtils, SvSerializer, SvSerializerJson,
  Classes, Generics.Collections, Graphics, SvStrings, DB, MidasLib, DBClient
  ,Rtti;

type
  TMyObjectList<T: class> = class(Generics.Collections.TObjectList<T>)
  public
    constructor Create; reintroduce; overload;
  end;

  TComplexConstructor = class
  private
    FName: string;
    FValue: string;
  public
    constructor Create(const AName: string; AValue: string);

    property Name: string read FName write FName;
    property Value: string read FValue write FValue;
  end;

  TName = class
  private
    FName: string;
  public
    constructor Create; overload;
    constructor Create(const AName: string); overload;

    property Name: string read FName write FName;
  end;

  TSurName = class(TName)
  private
    FSurName: string;
  public
    property SurName: string read FSurName write FSurName;
  end;

  TRegisterConstructor = class
  private
    FItems: TObjectList<TName>;
    FComplex: TComplexConstructor;
  public
    destructor Destroy; override;

    property Complex: TComplexConstructor read FComplex write FComplex;
    property Items: TObjectList<TName> read FItems write FItems;
  end;

  TDemoEnum = (deOne, deTwo, deThree);

  TNumbers = set of TDemoEnum;

  TDummy = class
  private
    FDummy: string;
  public
    constructor Create(); overload;
    constructor Create(const ADummyName: string); overload;

    property Dummy: string read FDummy write FDummy;
  end;

  TBeanSuperSuper = class
  private
    FName: string;
    FPassword: string;
    FItems: TList<Integer>;
    FDummies: TMyObjectList<TDummy>;
  public
    destructor Destroy; override;
   // [SvSerialize]
    property Name: string read FName write FName;
    [SvTransient]
    property Password: string read FPassword write FPassword;

    property Items: TList<Integer> read FItems write FItems;

    property Dummies: TMyObjectList<TDummy> read FDummies write FDummies;
  end;

  TBeanSuper = class
  private
    FLastName: string;
    FBean: TBeanSuperSuper;
  public
    constructor Create(); virtual;
    destructor Destroy; override;

    [SvSerialize]
    property Bean: TBeanSuperSuper read FBean write FBean;
    [SvSerialize]
    property LastName: string read FLastName write FLastName;
  end;

  TBean = class
  private
    FBeanSuper: TBeanSuper;
    FFirstName: string;
  public
    constructor Create(); virtual;
    destructor Destroy; override;

    [SvSerialize]
    property FirstName: string read FFirstName write FFirstName;
    [SvSerialize]
    property BeanSuper: TBeanSuper read FBeanSuper write FBeanSuper;
  end;


  TMyRec = record
  private
    FString: string;
    FInt: Integer;
    FDouble: Double;
    procedure SetString(const Value: string);
    procedure SetInt(const Value: Integer);
  public
    [SvSerialize]
    property AInt: Integer read FInt write SetInt;
    [SvSerialize]
    property AString: string read FString write SetString;
    [SvSerialize]
    property ADouble: Double read FDouble write FDouble;
  end;

  IDemoObj = interface
  ['{045BBB1C-89AC-4FAF-9B60-14DC79CCB5FC}']
    function GetName: string;
    procedure SetName(const Value: string);
    [SvSerialize]
    property Name: string read GetName write SetName;
  end;

  IListEnumerator<T> = interface(IInvokable)
    ['{4843AFBF-86D0-4C66-ADE1-E9432AB44E66}']
    function GetCurrent(): T;
    function MoveNext(): Boolean;
    property Current: T read GetCurrent;
  end;

  IList<T> = interface(IInvokable)
    ['{6C1FDDD9-8E9F-435B-B484-4E5BF34F78A5}']
    function GetEnumerator(): IListEnumerator<T>;

    function Add(AValue: T): Integer;
    procedure Clear();
    function GetValue(AIndex: Integer): T;
    function GetCount: Integer;
  end;

  IObjectList<T: class> = interface(IList<T>)
  end;

  TTestEnumerator<T> = class(TInterfacedObject, IListEnumerator<T>)
  private
    FList: TObject;
    FIndex: Integer;
  public
    constructor Create(AList: TObject); virtual;

    function GetCurrent(): T;
    function MoveNext(): Boolean;
    property Current: T read GetCurrent;
  end;

  TTestList<T> = class(TInterfacedObject, IList<T>)
  private
    FList: TList<T>;
  public
    constructor Create(); virtual;
    destructor Destroy; override;

    function GetEnumerator(): IListEnumerator<T>;

    function Add(AValue: T): Integer;
    procedure Clear();
    function GetValue(AIndex: Integer): T;
    function GetCount: Integer;
  end;

  TTestObjectList<T: class> = class(TInterfacedObject, IObjectList<T>)
  private
    FList: TObjectList<T>;
  public
    constructor Create(); virtual;
    destructor Destroy; override;

    function GetEnumerator(): IListEnumerator<T>;

    function Add(AValue: T): Integer;
    procedure Clear();
    function GetValue(AIndex: Integer): T;
    function GetCount: Integer;
  end;

  TBeanTestIntf = class
  private
    FList: IList<string>;
    FListObj: IObjectList<TBean>;
  public
    constructor Create(); virtual;
    destructor Destroy; override;


    property List: IList<string> read FList write FList;
    property ListObj: IObjectList<TBean> read FListObj write FListObj;
  end;


  (* say our JQGrid defined as:
  jQuery("#gridid").jqGrid({
    ...
   jsonReader : {
      root:"invdata",
      page: "currpage",
      total: "totalpages",
      records: "totalrecords",
      repeatitems: false,
      id: "0"
   },
  ...
  });
  *)

  TJQGridData = class
  private
    FTotalPages: Integer;
    FCurrPage: Integer;
    FTotalRecords: Integer;
    FInvData: TClientDataset;
  public
    constructor Create(); virtual;
    destructor Destroy; override;

    procedure FillData();
    procedure ClearData();
    function ToJSON(): string;
    procedure FromJSON(const AJSONString: string);


    [SvSerialize('totalpages')]
    property TotalPages: Integer read FTotalPages write FTotalPages;
    [SvSerialize('currpage')]
    property CurrentPage: Integer read FCurrPage write FCurrPage;
    [SvSerialize('totalrecords')]
    property TotalRecords: Integer read FTotalRecords write FTotalRecords;
    [SvSerialize('invdata')]
    property InvData: TClientDataset read FInvData write FInvData;
  end;


  TSimpleInside = class
  private
    FStringList: TStringList;
  public
    constructor Create;
    destructor Destroy; override;
    [SvSerialize]
    property StringList: TStringList read FStringList write FStringList;
  end;

  TSimple = class
  private
    FList: TArray<string>;
    FAList: Generics.Collections.TObjectList<TSimpleInside>;
  public
    constructor Create;
    destructor Destroy; override;

   // property AList: TObjectList<TSimpleInside> read FAList write FAList;
    [SvSerialize]
    property List: TArray<string> read FList write FList;
  end;

  TSimpleTValue = class
  private
    FValues: TArray<string>;
  public
    [SvSerialize]
    property Values: TArray<string> read FValues write FValues;
  end;

  TDemoObj = class(TInterfacedObject, IDemoObj)
  private
    FName: string;
    FTag: Integer;
    FDate: TDateTime;
    FEnumas: TDemoEnum;
    FMas: TArray<string>;
    FValue: Variant;
    FIsValid: Boolean;
    FList: TStrings;
    FList2: TList<Integer>;
    FMyRec: TMyRec;
    FColor: TColor;
    FFont: TFont;
    FIntf: IDemoObj;
    FMeth: TProc;
    FDouble: Double;
    FSet: TNumbers;
    FMas2: TArray<TMyRec>;
    FSvString: TSvString;
    FDict: TDictionary<string, TMyRec>;
    FDataset: TClientDataSet;
    FSimple: TSimple;
    function GetName: string;
    procedure SetName(const Value: string);
  public
    constructor Create();
    destructor Destroy; override;
    [SvSerialize]
    property ASet: TNumbers read FSet write FSet;
    [SvSerialize]
    property Name: string read GetName write SetName;
    [SvSerialize]
    property Tag: Integer read FTag write FTag;
    [SvSerialize]
    property DoubleVal: Double read FDouble write FDouble;
    [SvSerialize]
    property Date: TDateTime read FDate write FDate;
    [SvSerialize]
    property Enumas: TDemoEnum read FEnumas write FEnumas;
    [SvSerialize]
    property Mas: TArray<string> read FMas write FMas;
    [SvSerialize]
    property Mas2: TArray<TMyRec> read FMas2 write FMas2;
    [SvSerialize]
    property Value: Variant read FValue write FValue;
    [SvSerialize]
    property IsValid: Boolean read FIsValid write FIsValid;
    [SvSerialize]
    property List: TStrings read FList write FList;
    [SvSerialize]
    property List2: TList<Integer> read FList2 write FList2;
    [SvSerialize]
    property MyRec: TMyRec read FMyRec write FMyRec;
    [SvSerialize]
    property Color: TColor read FColor write FColor;
    [SvSerialize('MyFont')]
    property Font: TFont read FFont write FFont;
    [SvTransient]
    property Intf: IDemoObj read FIntf write FIntf;
    [SvSerialize]
    property Meth: TProc read FMeth write FMeth;
    [SvSerialize]
    property SvString: TSvString read FSvString write FSvString;
    [SvSerialize]
    property Dict: TDictionary<string, TMyRec> read FDict write FDict;
    [SvSerialize]
    property Dataset: TClientDataSet read FDataset write FDataset;
    [SvSerialize]
    property SimpleObj: TSimple read FSimple write FSimple;
  end;
  // Test methods for class TSvJsonSerializerFactory

  TestTSvJsonSerializerFactory = class(TTestCase)
  strict private
    FSerializer: TSvSerializer;
    FSvJsonSerializerFactory: ISerializer;
    FSerializerType: TSvSerializeFormat;
  public
    procedure SetUp; override;
    procedure TearDown; override;

    property Serializer: TSvSerializer read FSerializer;
    property SerializerType: TSvSerializeFormat read FSerializerType write FSerializerType;
  protected
    FILE_SERIALIZE: string;
    procedure TestEscapeValue();
  published
    //test methods
    procedure TestSerializeAndDeserialize();
    procedure TestAddObjectProperties();
    procedure TestRemoveObject();
    procedure TestSerializeRecord();

    procedure TestJQGrid();
    procedure TestSQLiteSerializeDeserialize();
    procedure TestSimpleClassInside;
    procedure TestSimpleArrayTValue();
    procedure TestOwnedObjects();
    procedure TestHelper();
    procedure TestRegisteredConstructor();
    procedure TestInterfaceList();
    procedure Test_ClassMethods();
    procedure TestNewPropertyAdded();
    procedure SerializeListOnly();
    procedure DateSupportTest();
  end;

  TestTSvSuperJsonSerializer = class(TestTSvJsonSerializerFactory)
  public
    procedure SetUp; override;
    procedure TearDown; override;
  end;

  TestTSvNativeXMLSerializer = class(TestTSvJsonSerializerFactory)
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure DeserializeFromXMLString();
  end;

implementation

uses
  Variants,
  DateUtils,
  TypInfo,
  Diagnostics,
  SvSerializerRtti,
  SvSerializer.Extensions.SQLite;

const
 // FILE_SERIALIZE = 'TestSerialize.json';


  KEY_VALUE: string = 'Main';
  KEY_DATASET: string = 'Dataset';

  PROP_STRING = 'Some unicode Português " Русский/ Ελληνικά';
  PROP_INTEGER : Integer = MaxInt;
  PROP_DOUBLE: Double = 15865874.1569854;
  PROP_ENUM: TDemoEnum = deThree;
  PROP_BOOLEAN: Boolean = True;
  PROP_COLOR: TColor = clRed;
  PROP_SET: TNumbers = [deTwo, deThree];
  PROP_ARRAY: array[0..2] of string = ('1','2','3');
  PROP_FONTNAME = 'Verdana';
  PROP_FONTSIZE = 25;
  COUNT_ARRAY = 3;

  FIELD_STRING = 'NAME';
  FIELD_INTEGER = 'ID';
  FIELD_DOUBLE = 'DOUBLE';
  FIELD_TDATETIME = 'DATETIME';

{ TDemoObj }

constructor TDemoObj.Create;
begin
  FName := '';
  Tag := 0;
  Date := Now;
  Enumas := deOne;
  FValue := Unassigned;
  FIsValid := False;
  FList := TStringList.Create;
  FList2 := TList<Integer>.Create;
  FFont := TFont.Create;
  FIntf := nil;
  FDict := TDictionary<string,TMyRec>.Create();
  FDataset := TClientDataSet.Create(nil);
  //init dataset
  FDataset.FieldDefs.Add(FIELD_STRING, ftWideString, 50);
  FDataset.FieldDefs.Add(FIELD_INTEGER, ftInteger);
  FDataset.FieldDefs.Add(FIELD_DOUBLE, ftFloat);
  FDataset.FieldDefs.Add(FIELD_TDATETIME, ftDateTime);
  FDataset.CreateDataSet;
  FSimple := TSimple.Create;
  SetLength(FSimple.FList, 0);
end;

destructor TDemoObj.Destroy;
begin
  FList.Free;
  FList2.Free;
  FFont.Free;
  FDict.Free;
  FDataset.Free;
  FSimple.Free;
  inherited;
end;

function TDemoObj.GetName: string;
begin
  Result := FName;
end;

procedure TDemoObj.SetName(const Value: string);
begin
  FName := Value;
end;

type
  TDateBean = class
  private
    FCurrentDate: TDate;
    FCurrentDateTime: TDateTime;
  public
    property CurrentDate: TDate read FCurrentDate write FCurrentDate;
    property CurrentDateTime: TDateTime read FCurrentDateTime write FCurrentDateTime;
  end;

procedure TestTSvJsonSerializerFactory.DateSupportTest;
var
  LBean: TDateBean;
  LNow: TDateTime;
  LOutputString: string;
begin
  LBean := TDateBean.Create;
  try
    LNow := EncodeDateTime(2012,1,1,12,0,0,0);
    LBean.CurrentDate := Today;
    LBean.CurrentDateTime := LNow;

    LOutputString := '';
    Serializer.SerializeObject(LBean, LOutputString, Serializer.SerializeFormat);
    CheckTrue(LOutputString <> '');
    CheckTrue(Pos('2012-01-01 12:00:00', LOutputString) > 1);
  finally
    LBean.Free;
  end;

  LBean := TDateBean.Create;
  try
    Serializer.DeSerializeObject(LBean, LOutputString, Serializer.SerializeFormat);
    CheckTrue(SameDate(Today, LBean.CurrentDate));
    CheckTrue(SameDateTime(LNow, LBean.CurrentDateTime) );
  finally
    LBean.Free;
  end;
end;

procedure TestTSvJsonSerializerFactory.SerializeListOnly;
var
  LList: TObjectList<TDummy>;
  LOutput: string;
begin
  LList := TObjectList<TDummy>.Create(True);
  try
    LList.Add(TDummy.Create('Foobar'));

    FSerializer.AddObject('', LList);
    LOutput := '';
    FSerializer.Serialize(LOutput, TEncoding.UTF8);
    CheckTrue(LOutput <> '');

    LList.Free;
    LList := TObjectList<TDummy>.Create(True);
    FSerializer.RemoveObject('');
    FSerializer.AddObject('', LList);
    FSerializer.DeSerialize(LOutput, TEncoding.UTF8);
    CheckEquals(1, LList.Count);
    CheckEquals('Foobar', LList[0].Dummy);
  finally
    LList.Free;
  end;
end;

procedure TestTSvJsonSerializerFactory.SetUp;
begin
  FSerializer := TSvSerializer.Create(FSerializerType);
  FSvJsonSerializerFactory := FSerializer.CreateConcreateSerializer;
  FILE_SERIALIZE := 'TestSerialize.json';
end;

procedure TestTSvJsonSerializerFactory.TearDown;
begin
  FSerializer.Free;
  FSvJsonSerializerFactory := nil;
end;

procedure TestTSvJsonSerializerFactory.TestAddObjectProperties;
var
  TestObj: TDemoObj;
begin
  TestObj := TDemoObj.Create;
  try
    TestObj.Name := PROP_STRING;
    TestObj.ASet := PROP_SET;
    TestObj.Value := PROP_DOUBLE;
    FSerializer.AddObjectCustomProperties('Test', TestObj, ['Name', 'ASet', 'Value']);

    FSerializer.Serialize('Test.json');


    TestObj.Free;
    TestObj := TDemoObj.Create;

    FSerializer.AddObjectCustomProperties('Test', TestObj, ['Name', 'Value']);

    FSerializer.DeSerialize('Test.json');

    CheckEqualsString(PROP_STRING, TestObj.Name);
    CheckEquals(PROP_DOUBLE, TestObj.Value);
    CheckFalse(PROP_SET = TestObj.ASet);

  finally
    TestObj.Free;
  end;
end;

procedure TestTSvJsonSerializerFactory.TestEscapeValue;

  function EscapeValue(const AValue: string): string;
  var
    i, ix: Integer;
    AChar: Char;

    procedure AddChars(const AChars: string; var Dest: string; var AIndex: Integer); inline;
    begin
      System.Insert(AChars, Dest, AIndex);
      System.Delete(Dest, AIndex + 2, 1);
      Inc(AIndex);
    end;

    procedure AddUnicodeChars(const AChars: string; var Dest: string; var AIndex: Integer); inline;
    begin
      System.Insert(AChars, Dest, AIndex);
      System.Delete(Dest, AIndex + 6, 1);
      Inc(AIndex, 5);
    end;

  begin
    Result := AValue;
    ix := 1;
    for i := 1 to System.Length(AValue) do
    begin
      AChar :=  AValue[i];
      case AChar of
        '/', '\', '"':
        begin
          System.Insert('\', Result, ix);
          Inc(ix, 2);
        end;
        #8:  //backspace \b
        begin
          AddChars('\b', Result, ix);
        end;
        #9:
        begin
          AddChars('\t', Result, ix);
        end;
        #10:
        begin
          AddChars('\n', Result, ix);
        end;
        #12:
        begin
          AddChars('\f', Result, ix);
        end;
        #13:
        begin
          AddChars('\r', Result, ix);
        end;
        #0 .. #7, #11, #14 .. #31:
        begin
          AddUnicodeChars('\u' + IntToHex(Word(AChar), 4), Result, ix);
        end
        else
        begin
          if Word(AChar) > 255 then
          begin
            AddUnicodeChars('\u' + IntToHex(Word(AChar), 4), Result, ix);
          end
          else
          begin
            Inc(ix);
          end;
        end;
      end;
    end;
  end;

  function JSONWideString(const ws: String): string;
  var
    C: char;
  begin
    result := '"';
    for C in ws do begin
      if ord(C) > 255
      then result := result + '\u' + IntToHex(ord(C), 4) //Format('\u%.04x', [ord(C)])
      else
        case C of
          #0 .. #7, #9, #11, #12, #14 .. #31: result := result + '\u' + IntToHex(ord(C), 4);// Format('\u%.04x', [ord(C)]);
          #8: result := result + '\t';
          #10: result := result + '\n';
          #13: result := result + '\r';
          '"': result := result + '\"';
          '\': result := result + '\\';
        else result := result + C;
        end;
    end;

    result := result + '"';
  end;

var
  sRes: string;
  sw: TStopwatch;
  i: Integer;
  iMs1, iMs2: Int64;

const
  CTITERATIONS = 50000;
  cTest: string = 'Lorem ipsum dolor sit amet consectetuer euismod a "sed" adipiscing neque. Pretium ac Donec id facilisi eget sociis Nullam lacinia pharetra Sed. Eu Vivamus Nullam tincidunt malesuada Morbi ac felis mi Praesent lobortis. Lorem Sed tincidunt at interdum '+
    'Aenean metus Curabitur et metus fames. Suscipit Donec nunc adipiscing ligula id elit nonummy a et. '+#10+
		'Congue Aliquam Nam pede mauris/ laoreet cursus ipsum Praesent congue quis. Vitae cursus ut at orci tellus Aenean Phasellus elit dictumst urna.'+
    ' Lacinia tellus arcu a elit pretium lobortis nec dis elit convallis. Pede congue ut ac eget In orci Nunc In auctor a. Metus'+
    ' penatibus orci nibh Proin et odio habitasse cursus et aliquam. Ac lacinia tortor nibh habitasse augue Vestibulum Quisque wisi. '+#10+
		'Id elit pellentesque quis facilisis et Vestibulum accumsan quis eu "Vivamus". Adipiscing Nam egestas ac'+
    ' hac feugiat a vestibulum rutrum in facilisi. Scelerisque pretium vitae pede nunc mauris mauris congue lobortis metus molestie. Morbi fermentum pretium sagittis Ma'+
    'ecenas risus Integer et Nullam malesuada felis. Laoreet augue Aenean lacus dolor nec arcu congue tristique In feugiat. Cursus tincidunt semper nascetur. '+#10+
		'Auctor et sed dui Nulla nec \faucibus Ut at\ vel et. Est Lorem Lorem orci amet condimentum hendrerit'+
    ' elit Morbi libero Ut. Nunc quis et pulvinar magna fermentum wisi quis molestie mauris ac. Risus condimentum vel morbi id ante est pede penatibus tincidunt Pellentesque'+
    '. Eros pharetra ipsum montes accumsan malesuada ac rhoncus at id vitae. Suspendisse sapien diam id In. '+#10+
		'Aliquet /orci Nam Nam consequat Nam orci est elit neque et. Nulla ac id pretium auctor scelerisque '+
    'nunc nunc platea laoreet ornare. Montes turpis lacinia "Phasellus" tempus lacinia laoreet metus arcu tristique orci. Non tellus turpis urna Donec Phasellus et ut justo'+
    ' adipiscing pharetra. Mauris ridiculus adipiscing justo orci Curabitur Nunc semper eros tristique ipsum. Porttitor hac felis at justo Nulla In Sed tristique mattis. ';
begin
  sw := TStopwatch.StartNew;
  try
    for i := 0 to CTITERATIONS - 1 do
    begin
      sRes := '';
      sRes := EscapeValue(cTest);
    end;
  finally
    sw.Stop;
  end;

  iMs1 := sw.ElapsedMilliseconds;

  sw := TStopwatch.StartNew;
  try
    for i := 0 to CTITERATIONS - 1 do
    begin
      sRes := '';
      sRes := JSONWideString(cTest);
    end;
  finally
    sw.Stop;
  end;

  iMs2 := sw.ElapsedMilliseconds;

  Status(Format('Iterations: %D. 1: %D ms. 2: %D ms.',
    [CTITERATIONS, iMs1, iMs2]));

  CheckTrue(iMs1 < iMs2);
end;

type
  THelperTest = class
  private
    FFoo: string;
  public
    property Foo: string read FFoo write FFoo;
  end;

procedure TestTSvJsonSerializerFactory.TestHelper;
var
  LBean: THelperTest;
  LJson: string;
const
  HELPER_JSON = '{' + #13#10 + ' "Foo": "Bar"'+ #13#10 + '}';
begin
  LBean := THelperTest.Create;
  try
    LBean.Foo := 'Bar';
    LJson := LBean.ToJsonString();
    CheckEqualsString(HELPER_JSON, LJson);
  finally
    LBean.Free;
  end;

  LBean := THelperTest.FromJsonString(HELPER_JSON);
  try
    CheckEqualsString('Bar', LBean.Foo);
  finally
    LBean.Free;
  end;
end;

procedure TestTSvJsonSerializerFactory.TestInterfaceList;
var
  LBean: TBeanTestIntf;
 // LAddBean: TBean;
  LJson: string;
begin
  LBean := TBeanTestIntf.Create;
  try
    LBean.List.Add('Foo');
    LBean.List.Add('Bar');

  //  LAddBean := TBean.Create;
   // LAddBean.FirstName := '1Bean';
   // LBean.ListObj.Add(LAddBean);

    LJson := '';
    LJson := LBean.ToJsonString;
    CheckTrue(LJson <> '');
    LBean.Free;

    LBean := TBeanTestIntf.Create;
    LBean.FromSerializedString(LJson, sstSuperJson);
    CheckTrue(Assigned(LBean.List), 'Interface not assigned');
    CheckEquals(2, LBean.List.GetCount);
    CheckEquals('Foo', LBean.List.GetValue(0));
    CheckEquals('Bar', LBean.List.GetValue(1));
  //  CheckEquals('1Bean', LBean.ListObj.GetValue(0).FirstName);
  finally
    LBean.Free;
  end;
end;

procedure TestTSvJsonSerializerFactory.TestJQGrid;
var
  obj: TJQGridData;
  sJson: TSvString;
begin
  obj := TJQGridData.Create;
  try
    obj.FillData;

    sJson := obj.ToJSON;

    sJson.SaveToFile('JQGrid.json');

    obj.ClearData;

    CheckEquals(0, obj.InvData.RecordCount);

    obj.FromJSON(sJson);

    CheckEquals(10, obj.InvData.RecordCount);
  finally
    obj.Free;
  end;
end;

procedure TestTSvJsonSerializerFactory.TestNewPropertyAdded;
var
  LName: TName;
  LSurname: TSurName;
  LOutput: string;
begin
  LName := TName.Create('Bob');
  LSurname := TSurName.Create('John');
  try
    LSurname.SurName := 'Marley';
    LOutput := '';
    TSvSerializer.SerializeObject(LName, LOutput, SerializerType);
    CheckTrue(LOutput <> '');

    TSvSerializer.DeSerializeObject(LSurname, LOutput, SerializerType);
    CheckEquals('Bob', LSurname.Name);
    CheckEquals('Marley', LSurname.SurName);
  finally
    LName.Free;
    LSurname.Free;
  end;
end;

procedure TestTSvJsonSerializerFactory.TestOwnedObjects;
var
  LBean: TBean;
  LJsonString: string;
begin
  LBean := TBean.Create;
  try
    LJsonString := '';
    LBean.FirstName := 'Bob';
    LBean.BeanSuper := TBeanSuper.Create;
    LBean.BeanSuper.LastName := 'Marley';
    LBean.BeanSuper.Bean := TBeanSuperSuper.Create;
    LBean.BeanSuper.Bean.Name := 'Junior';
    LBean.BeanSuper.Bean.Password := 'password';
    LBean.BeanSuper.Bean.Items := TList<Integer>.Create();
    LBean.BeanSuper.Bean.Items.AddRange([1,2,3]);
    LBean.BeanSuper.Bean.Dummies := TMyObjectList<TDummy>.Create();
    LBean.BeanSuper.Bean.Dummies.Add(TDummy.Create('Foo'));
    LBean.BeanSuper.Bean.Dummies.Add(TDummy.Create('Bar'));

    FSerializer.AddObject('', LBean);

    FSerializer.Serialize(LJsonString, TEncoding.UTF8);
    CheckTrue(LJsonString <> '');

    FSerializer.ClearObjects;

    LBean.Free;
    LBean := TBean.Create;

    FSerializer.AddObject('', LBean);
    FSerializer.DeSerialize(LJsonString, TEncoding.UTF8);

    CheckEqualsString('Bob', LBean.FirstName);
    CheckEqualsString('Marley', LBean.BeanSuper.LastName);
    CheckEqualsString('Junior', LBean.BeanSuper.Bean.Name);
    CheckEqualsString('',LBean.BeanSuper.Bean.Password);
    CheckEquals(3, LBean.BeanSuper.Bean.Items.Count);
    CheckEquals(1, LBean.BeanSuper.Bean.Items[0]);
    CheckEquals(2, LBean.BeanSuper.Bean.Items[1]);
    CheckEquals(3, LBean.BeanSuper.Bean.Items[2]);
    CheckEquals(2, LBean.BeanSuper.Bean.Dummies.Count);
    CheckEqualsString('Foo', LBean.BeanSuper.Bean.Dummies[0].Dummy);
    CheckEqualsString('Bar', LBean.BeanSuper.Bean.Dummies[1].Dummy);
  finally
    LBean.Free;
  end;
end;

procedure TestTSvJsonSerializerFactory.TestRegisteredConstructor;
var
  LBean: TRegisterConstructor;
  LJson: string;
begin
  TSvRttiInfo.RegisterConstructor(TypeInfo(TObjectList<TName>)
    , function: TObject
    begin
      Result := TObjectList<TName>.Create(True);
    end);

  TSvRttiInfo.RegisterConstructor(TypeInfo(TComplexConstructor)
    , function: TObject
    begin
      Result := TComplexConstructor.Create('', '');
    end);

  LBean := TRegisterConstructor.Create;
  try
    LBean.Items := TObjectList<TName>.Create(True);
    LBean.Items.Add(TName.Create('Bob'));
    LBean.Items.Add(TName.Create('John'));

    LBean.Complex := TComplexConstructor.Create('Bob', 'John');

    LJson := LBean.ToJsonString;
    CheckTrue(LJson <> '');
    LBean.Free;

    LBean := TRegisterConstructor.FromJsonString(LJson);
    CheckEqualsString('Bob', LBean.Items[0].Name);
    CheckEqualsString('John', LBean.Items[1].Name);
    CheckEqualsString('Bob', LBean.Complex.Name);
    CheckEqualsString('John', LBean.Complex.Value);
  finally
    LBean.Free;
  end;
end;

procedure TestTSvJsonSerializerFactory.TestRemoveObject;
var
  TestObj, TestObj2, temp: TDemoObj;
begin
  TestObj := TDemoObj.Create;
  TestObj2 := TDemoObj.Create;
  try
    FSerializer.AddObject('Test', TestObj);
    FSerializer.AddObject('Test2', TestObj2);

    CheckEquals(2, FSerializer.Count);

    FSerializer.RemoveObject(TestObj);

    CheckEquals(1, FSerializer.Count);

    temp := TDemoObj(FSerializer['Test2']);

    CheckTrue(temp = TestObj2);
  finally
    TestObj.Free;
    TestObj2.Free;
  end;
end;

procedure TestTSvJsonSerializerFactory.TestSerializeAndDeserialize;
var
  TestObj: TDemoObj;
  ARec1, ARec2, ARec3: TMyRec;
  AEnum: TPair<string,TMyRec>;
  i: Integer;
begin
  TestObj := TDemoObj.Create;
  try
    //set our properties

    {$REGION 'Set Properties'}
    //string property
    TestObj.Name  := PROP_STRING;
    //integer property
    TestObj.Tag := PROP_INTEGER;
    //datetime property
    TestObj.Date := Today;
    //double property
    TestObj.DoubleVal := PROP_DOUBLE;
    //enum property
    TestObj.Enumas := PROP_ENUM;
    //boolean property
    TestObj.IsValid := PROP_BOOLEAN;
    //TColor property
    TestObj.Color := PROP_COLOR;
    //set property
    TestObj.ASet := PROP_SET;
    //variant property
    TestObj.Value := PROP_DOUBLE;
    //array property
    TestObj.Mas := TArray<string>.Create('1','2','3');
    //complex array
    ARec1.AString := '1';
    ARec1.AInt := 111;
    ARec2.AString := '2';
    ARec2.AInt := 222;
    ARec3.AString := '3';
    ARec3.AInt := 333;
    TestObj.Mas2 := TArray<TMyRec>.Create(ARec1, ARec2, ARec3);
    //TStrings property
    TestObj.List.AddStrings(TestObj.Mas);
    //Generic List property
    TestObj.List2.AddRange([1,2,3]);
    // record property
    TestObj.MyRec.AString := PROP_STRING;
    TestObj.MyRec.AInt := PROP_INTEGER;
    //TFont property
    TestObj.Font.Name := PROP_FONTNAME;
    TestObj.Font.Size := PROP_FONTSIZE;
    //TSvString property
    TestObj.SvString := PROP_STRING;
    //TDictionary property
    TestObj.Dict.Add(PROP_STRING, ARec1);
    TestObj.Dict.Add('1', ARec2);
   // TestObj.Dict.Add(PROP_STRING, PROP_STRING);
   // TestObj.Dict.Add('1', '111');
    TestObj.SimpleObj.List := TArray<string>.Create(PROP_STRING, PROP_STRING, PROP_STRING);
    //TDataset property
    for i := 1 to 10 do
    begin
      TestObj.FDataset.Append;

      TestObj.FDataset.FieldByName(FIELD_STRING).AsString := PROP_STRING;
      TestObj.FDataset.FieldByName(FIELD_INTEGER).AsInteger := i;
      TestObj.FDataset.FieldByName(FIELD_DOUBLE).AsFloat := PROP_DOUBLE;
      TestObj.FDataset.FieldByName(FIELD_TDATETIME).AsDateTime := Today;

      TestObj.FDataset.Post;
    end;
    {$ENDREGION}


    ///////////////////////////////////////////


  //  FSerializer.AddObject(KEY_DATASET, FDataset);

    FSerializer.AddObject(KEY_VALUE, TestObj);
    //serialize to file
    FSerializer.Serialize(FILE_SERIALIZE);

    CheckTrue(FileExists(FILE_SERIALIZE));

    FSerializer.RemoveObject(KEY_VALUE);
   // FSerializer.RemoveObject(KEY_DATASET);
    CheckTrue(FSerializer.Count = 0);
    //recreate our object to make sure that it's values reset to their initial state
    TestObj.Free;
    TestObj := TDemoObj.Create;
    //add newly created object
    FSerializer.AddObject(KEY_VALUE, TestObj);
    CheckTrue(FSerializer.Count = 1);
    //deserialize from file
    FSerializer.DeSerialize(FILE_SERIALIZE);
    //check our properties


    {$REGION 'Check Properties'}
    //string property
    CheckEqualsString(TestObj.Name, PROP_STRING);
    //integer property
    CheckEquals(TestObj.Tag, PROP_INTEGER);
    //datetime property
    CheckEquals(TestObj.Date, Today);
    //double property
    CheckEquals(TestObj.DoubleVal, PROP_DOUBLE);
    //enum property
    CheckTrue(TestObj.Enumas = PROP_ENUM);
    //boolean property
    CheckTrue(TestObj.IsValid = PROP_BOOLEAN);
    //TColor property
    CheckEquals(TestObj.Color, PROP_COLOR);
    //set property
    CheckTrue(TestObj.ASet = PROP_SET);
    //variant property
    CheckTrue(TestObj.Value = PROP_DOUBLE);
    //array property
    CheckTrue(Length(TestObj.Mas) = COUNT_ARRAY);
    CheckEqualsString('1', TestObj.Mas[0]);
    CheckEqualsString('2', TestObj.Mas[1]);
    CheckEqualsString('3', TestObj.Mas[2]);
    //complex array property
    CheckTrue(Length(TestObj.Mas2) = COUNT_ARRAY);
    CheckEqualsString('1', TestObj.Mas2[0].AString);
    CheckEqualsString('2', TestObj.Mas2[1].AString);
    CheckEqualsString('3', TestObj.Mas2[2].AString);
    CheckEquals(111, TestObj.Mas2[0].AInt);
    CheckEquals(222, TestObj.Mas2[1].AInt);
    CheckEquals(333, TestObj.Mas2[2].AInt);
    //TStrings property
    CheckEquals(COUNT_ARRAY, TestObj.List.Count);
    CheckEqualsString('1', TestObj.List[0]);
    CheckEqualsString('2', TestObj.List[1]);
    CheckEqualsString('3', TestObj.List[2]);
    //Generic List property
    CheckEquals(COUNT_ARRAY, TestObj.List2.Count);
    CheckEquals(1, TestObj.List2[0]);
    CheckEquals(2, TestObj.List2[1]);
    CheckEquals(3, TestObj.List2[2]);
    // record property
    CheckEqualsString(PROP_STRING, TestObj.MyRec.AString);
    CheckEquals(PROP_INTEGER, TestObj.MyRec.AInt);
    //TFont property
    CheckEqualsString(PROP_FONTNAME, TestObj.Font.Name);
    CheckEquals(PROP_FONTSIZE, TestObj.Font.Size);
    //TSvString property
    CheckEqualsString(PROP_STRING, TestObj.SvString);
    //TDictionary property
 //   CheckTrue(TestObj.Dict.ContainsKey(PROP_STRING));
 //   CheckTrue(TestObj.Dict.ContainsValue(PROP_STRING));
    CheckTrue(TestObj.Dict.ContainsKey(PROP_STRING));
    i := 0;
    for AEnum in TestObj.Dict do
    begin
      if i = 1 then
      begin
        CheckEqualsString(PROP_STRING, AEnum.Key);
        CheckEqualsString(ARec1.AString, AEnum.Value.AString);
        CheckEquals(ARec1.AInt, AEnum.Value.AInt);
      end
      else
      begin
        CheckEqualsString('1', AEnum.Key);
        CheckEqualsString(ARec2.AString, AEnum.Value.AString);
        CheckEquals(ARec2.AInt, AEnum.Value.AInt);
      end;

      Inc(i);
    end;
    //obkect and array in it
    CheckEquals(3, Length(TestObj.SimpleObj.List));
    CheckEqualsString(PROP_STRING, TestObj.SimpleObj.List[0]);
    CheckEqualsString(PROP_STRING, TestObj.SimpleObj.List[1]);
    CheckEqualsString(PROP_STRING, TestObj.SimpleObj.List[2]);

    //TDataset property
    CheckEquals(10, TestObj.Dataset.RecordCount);
    TestObj.Dataset.First;

    i := 1;
    while not TestObj.Dataset.Eof do
    begin
      CheckEqualsString(PROP_STRING, TestObj.Dataset.FieldByName(FIELD_STRING).AsString);
      CheckEquals(i, TestObj.Dataset.FieldByName(FIELD_INTEGER).AsInteger);
      CheckEquals(PROP_DOUBLE, TestObj.Dataset.FieldByName(FIELD_DOUBLE).AsFloat);
      CheckEquals(Today, TestObj.Dataset.FieldByName(FIELD_TDATETIME).AsDateTime);

      TestObj.Dataset.Next;
      Inc(i);
    end;
    {$ENDREGION}


  finally
    TestObj.Free;
  end;
end;

const
  JSON_STRING = '{"TMyRec.Main":{"FString":"Some unicode Português \" Русский/ Ελληνικά","FInt":2147483647,"FDouble":15865874.1569854}}';

procedure TestTSvJsonSerializerFactory.TestSerializeRecord;
var
  ARec: TMyRec;
  FString: TSvString;
  FJsonString: string;
begin
  ARec.AString := PROP_STRING;
  ARec.AInt := PROP_INTEGER;
  ARec.ADouble := PROP_DOUBLE;

  FSerializer.Marshall<TMyRec>(ARec, 'Record.json');


  ARec.AString := '';
  ARec.AInt := -1;
  ARec.ADouble := -1;

  ARec := FSerializer.UnMarshall<TMyRec>('Record.json');

  CheckEqualsString(PROP_STRING, ARec.AString);
  CheckEquals(PROP_INTEGER, ARec.AInt);
  CheckEquals(PROP_DOUBLE, ARec.ADouble);

  //test string
  FString.LoadFromFile('Record.json');
  CheckTrue(FString <> '');
  FSerializer.Marshall<TMyRec>(ARec, FJsonString, TEncoding.UTF8);
  CheckEqualsString(FString, FJsonString);
  ARec :=  FSerializer.UnMarshall<TMyRec>(FJsonString, TEncoding.UTF8);
  CheckEqualsString(PROP_STRING, ARec.AString);
  CheckEquals(PROP_INTEGER, ARec.AInt);
  CheckEquals(PROP_DOUBLE, ARec.ADouble);
end;

procedure TestTSvJsonSerializerFactory.TestSimpleArrayTValue;
var
  obj: TSimpleTValue;
  i: Integer;
begin
  obj := TSimpleTValue.Create;
  try
    FILE_SERIALIZE := 'testSimpleTValue.json';

    SetLength(obj.FValues, 3);
    for i := Low(obj.FValues) to High(obj.FValues) do
    begin
      obj.FValues[i] := PROP_STRING + ' ' + IntToStr(i);
    end;

    FSerializer.AddObject('', obj);
    FSerializer.Serialize(FILE_SERIALIZE);
    FSerializer.Free;
    obj.Free;

    FSerializer := TSvSerializer.Create();
    obj := TSimpleTValue.Create;
    FSerializer.AddObject('', obj);

    FSerializer.DeSerialize(FILE_SERIALIZE);

    for i := Low(obj.FValues) to High(obj.FValues) do
    begin
      CheckEqualsString(PROP_STRING + ' ' + IntToStr(i), obj.Values[i]);
    end;

  finally
    obj.Free;
  end;
end;

procedure TestTSvJsonSerializerFactory.TestSimpleClassInside;
var
  obj: TSimple;
  inside: TSimpleInside;
  i: Integer;
begin
  obj := TSimple.Create;

  FILE_SERIALIZE := 'testSimpleInside.json';
  //set properties
  for i := 0 to 3 - 1 do
  begin
    inside := TSimpleInside.Create;
    inside.StringList.Add(PROP_STRING);
    inside.StringList.Add(PROP_STRING);
    inside.StringList.Add(PROP_STRING);
    obj.FAList.Add(inside);
  end;

  FSerializer.AddObject('', obj);

  FSerializer.Serialize(FILE_SERIALIZE);
  FSerializer.Free;

  FSerializer := TSvSerializer.Create();
  obj.Free;
  obj := TSimple.Create;
  FSerializer.AddObject('', obj);
  try
    FSerializer.DeSerialize(FILE_SERIALIZE);

 //   CheckEquals(3, obj.AList.Count);
   // CheckEquals(3, obj.AList[0].StringList.Count);
  //  CheckEqualsString(PROP_STRING,  obj.AList[0].StringList[0]);
  finally
    obj.Free;
  end;
end;

procedure TestTSvJsonSerializerFactory.TestSQLiteSerializeDeserialize;
begin
  FSerializer.Free;
  FSerializer := TSQLiteSerializer.Create();

  FILE_SERIALIZE := 'test.db3';

  TestSerializeAndDeserialize();
end;

procedure TestTSvJsonSerializerFactory.Test_ClassMethods;
var
  LBean: TBean;
  LOutput: string;
begin
  LBean := TBean.Create;
  try
    LBean.FirstName := 'Class';

    TSvSerializer.SerializeObject(LBean, LOutput, SerializerType);
    CheckTrue(LOutput <> '');
    LBean.Free;
    LBean := TBean.Create;

    TSvSerializer.DeSerializeObject(LBean, LOutput, SerializerType);
    CheckEquals('Class', LBean.FirstName);
  finally
    LBean.Free;
  end;
end;

{ TMyRec }

procedure TMyRec.SetInt(const Value: Integer);
begin
  FInt := Value;
end;

procedure TMyRec.SetString(const Value: string);
begin
  FString := Value;
end;

{ TJQGridData }

procedure TJQGridData.ClearData;
begin
  FInvData.First;
  while not FInvData.Eof do
  begin
    FInvData.Delete;
  end;
end;

constructor TJQGridData.Create;
begin
  inherited Create();
  FInvData := TClientDataSet.Create(nil);
  FInvData.FieldDefs.Add('invid', ftInteger);
  FInvData.FieldDefs.Add('invdate',ftDateTime);
  FInvData.FieldDefs.Add('amount',ftFloat);
  FInvData.FieldDefs.Add('tax',ftInteger);
  FInvData.FieldDefs.Add('total',ftFloat);
  FInvData.FieldDefs.Add('note',ftWideString, 255);
  FInvData.CreateDataSet;

  FTotalPages := 2;
  FCurrPage := 1;
  FTotalRecords := 10;
end;

destructor TJQGridData.Destroy;
begin
  FInvData.Free;
  inherited Destroy;
end;

procedure TJQGridData.FillData;
var
  i: Integer;
begin
  for i := 1 to 10 do
  begin
    FInvData.Append;

    FInvData.FieldByName('invid').AsInteger := i;
    FInvData.FieldByName('invdate').AsDateTime := Today;
    FInvData.FieldByName('amount').AsFloat := i * 100;
    FInvData.FieldByName('tax').AsInteger := i + 30;
    FInvData.FieldByName('total').AsFloat := i * 101;
    FInvData.FieldByName('note').AsString := PROP_STRING;

    FInvData.Post;
  end;
end;

procedure TJQGridData.FromJSON(const AJSONString: string);
var
  FSer: TSvSerializer;
begin
  FSer := TSvSerializer.Create();
  try
    FSer.AddObject('', Self);
    FSer.DeSerialize(AJSONString, TEncoding.UTF8);
  finally
    FSer.Free;
  end;
end;

function TJQGridData.ToJSON: string;
var
  FSer: TSvSerializer;
begin
  Result := '';
  FSer := TSvSerializer.Create();
  try
    FSer.AddObject('', Self);
    FSer.Serialize(Result, TEncoding.UTF8);
  finally
    FSer.Free;
  end;
end;

{ TSimpleInside }

constructor TSimpleInside.Create;
begin
  FStringList := TStringList.Create;
end;

destructor TSimpleInside.Destroy;
begin
  FStringList.Free;
  inherited;
end;

{ TSimple }

constructor TSimple.Create;
begin
  FAList := Generics.Collections.TObjectList<TSimpleInside>.Create(True);
end;

destructor TSimple.Destroy;
begin
  FAList.Free;
  inherited;
end;

{ TBean }

constructor TBean.Create;
begin
  inherited;
 // FBeanSuper := TBeanSuper.Create;
end;

destructor TBean.Destroy;
begin
  FBeanSuper.Free;
  inherited;
end;

{ TBeanSuper }

constructor TBeanSuper.Create;
begin
  inherited;
 // FBean := TBeanSuperSuper.Create;
end;

destructor TBeanSuper.Destroy;
begin
  FBean.Free;
  inherited;
end;

{ TBeanSuperSuper }

destructor TBeanSuperSuper.Destroy;
begin
  FItems.Free;
  FDummies.Free;
  inherited;
end;

{ TDummy }

constructor TDummy.Create;
begin
  inherited Create;
end;

constructor TDummy.Create(const ADummyName: string);
begin
  inherited Create;
  FDummy := ADummyName;
end;

{ TObjectList<T> }

constructor TMyObjectList<T>.Create;
begin
  inherited Create(True);
end;

{ TestTSvSuperJsonSerializer }

procedure TestTSvSuperJsonSerializer.SetUp;
begin
  SerializerType := sstSuperJson;
  inherited;
end;

procedure TestTSvSuperJsonSerializer.TearDown;
begin
  inherited;
end;

{ TestTSvNativeXMLSerializer }

type
  TAsmuo = class
  private
    FASM_ID: Integer;
    FASM_VARDAS: string;
    FASM_PAVARDE: string;
  public
    property ASM_ID: Integer read FASM_ID write FASM_ID;
    property ASM_VARDAS: string read FASM_VARDAS write FASM_VARDAS;
    property ASM_PAVARDE: string read FASM_PAVARDE write FASM_PAVARDE;
  end;

procedure TestTSvNativeXMLSerializer.DeserializeFromXMLString;
var
  LAsmenys: TObjectList<TAsmuo>;
const
  ASMENYS_XML: string = '<?xml version = ''1.0'' encoding=''UTF-8'' ?> '+
  '<ASMENYS> '+
  '<ASMUO> '+
  '	<ASM_ID>111</ASM_ID> '+
  '	<ASM_VARDAS>VARDENĖ</ASM_VARDAS> '+
  '	<ASM_PAVARDE>PAVARDENĖ</ASM_PAVARDE> '+
  '</ASMUO> '+
  '<ASMUO> '+
  '	<ASM_ID>112</ASM_ID> '+
  '	<ASM_VARDAS>VARDENIS</ASM_VARDAS> '+
  '	<ASM_PAVARDE>PAVARDENIS</ASM_PAVARDE> '+
  '</ASMUO> '+
  '</ASMENYS> ';
begin
  LAsmenys := TObjectList<TAsmuo>.Create(True);
  try
    TSvSerializer.DeSerializeObject(LAsmenys, ASMENYS_XML, sstNativeXML);
    CheckEquals(2, LAsmenys.Count);
    CheckEquals(111, LAsmenys[0].ASM_ID);
    CheckEquals(112, LAsmenys[1].ASM_ID);

    CheckEquals('VARDENĖ', LAsmenys[0].ASM_VARDAS);
    CheckEquals('VARDENIS', LAsmenys[1].ASM_VARDAS);

    CheckEquals('PAVARDENĖ', LAsmenys[0].ASM_PAVARDE);
    CheckEquals('PAVARDENIS', LAsmenys[1].ASM_PAVARDE);
  finally
    LAsmenys.Free;
  end;
end;

procedure TestTSvNativeXMLSerializer.SetUp;
begin
  SerializerType := sstNativeXML;
  inherited;
  FILE_SERIALIZE := 'TestNativeXMLSerialize.xml';
end;

procedure TestTSvNativeXMLSerializer.TearDown;
begin
  inherited;
end;

{ TName }

constructor TName.Create;
begin
  inherited Create;
end;

constructor TName.Create(const AName: string);
begin
  Create;
  FName := AName;
end;

{ TRegisterConstructor }

destructor TRegisterConstructor.Destroy;
begin
  FItems.Free;
  FComplex.Free;
  inherited Destroy;
end;

{ TComplexConstructor }

constructor TComplexConstructor.Create(const AName: string; AValue: string);
begin
  inherited Create();
  FName := AName;
  FValue := AValue;
end;

{ TTestList<T> }

function TTestList<T>.Add(AValue: T): Integer;
begin
  Result := FList.Add(AValue);
end;

procedure TTestList<T>.Clear;
begin
  FList.Clear;
end;

constructor TTestList<T>.Create;
begin
  inherited Create;
  FList := TList<T>.Create;
end;

destructor TTestList<T>.Destroy;
begin
  FList.Free;
  inherited;
end;

function TTestList<T>.GetCount: Integer;
begin
  Result := FList.Count;
end;

function TTestList<T>.GetEnumerator: IListEnumerator<T>;
begin
  Result := TTestEnumerator<T>.Create(Self);
end;

function TTestList<T>.GetValue(AIndex: Integer): T;
begin
  Result := FList[AIndex];
end;

{ TTestEnumerator<T> }

constructor TTestEnumerator<T>.Create(AList: TObject);
begin
  inherited Create;
  FList := AList;
  FIndex := -1;
end;

function TTestEnumerator<T>.GetCurrent: T;
begin
  Result := TTestList<T>(FList).GetValue(FIndex);
end;

function TTestEnumerator<T>.MoveNext: Boolean;
begin
  if FIndex >= TTestList<T>(FList).GetCount then
    Exit(False);
  Inc(FIndex);
  Result := FIndex < TTestList<T>(FList).GetCount;
end;

{ TBeanTestIntf }

constructor TBeanTestIntf.Create;
begin
  inherited Create;
  FList := TTestList<string>.Create;
 // FListObj := TTestObjectList<TBean>.Create;
end;

destructor TBeanTestIntf.Destroy;
begin
  inherited;
end;

{ TTestObjectList<T> }

function TTestObjectList<T>.Add(AValue: T): Integer;
begin
  Result := FList.Add(AValue);
end;

procedure TTestObjectList<T>.Clear;
begin
  FList.Clear;
end;

constructor TTestObjectList<T>.Create;
begin
  inherited Create;
  FList := TObjectList<T>.Create(True);
end;

destructor TTestObjectList<T>.Destroy;
begin
  FList.Free;
  inherited;
end;

function TTestObjectList<T>.GetCount: Integer;
begin
  Result := FList.Count;
end;

function TTestObjectList<T>.GetEnumerator: IListEnumerator<T>;
begin
  Result := TTestEnumerator<T>.Create(Self);
end;

function TTestObjectList<T>.GetValue(AIndex: Integer): T;
begin
  Result := FList[AIndex];
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTSvJsonSerializerFactory.Suite);
  RegisterTest(TestTSvSuperJsonSerializer.Suite);
  RegisterTest(TestTSvNativeXMLSerializer.Suite);
end.

