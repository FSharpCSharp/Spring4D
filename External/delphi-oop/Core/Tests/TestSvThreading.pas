unit TestSvThreading;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, Classes, SysUtils, SvThreading, Diagnostics;

type
  {$HINTS OFF}

  TestTSvFuture = class(TTestCase)
  private
    FSvFuture: TSvFuture<Integer>;
    sw: TStopwatch;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestExecute;
  end;

  TestTSvParallel = class(TTestCase)
  private
  //  sw: TStopwatch;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestForEach;
    procedure TestAsync();
  end;

implementation

uses
  SyncObjs, TestExtensions, Forms;

{ TestTSvFuture }

procedure TestTSvFuture.SetUp;
begin
  inherited;

end;

procedure TestTSvFuture.TearDown;
begin
  inherited;

end;

const
  INTVAL = 100;
  INTVAL2 = 111111;

procedure TestTSvFuture.TestExecute;
var
  func1, func2: TFunc<Integer>;
begin
  sw := TStopwatch.StartNew;
  func1 := function: Integer
    begin
      Sleep(1100);
      Result := INTVAL;
    end;

  func2 := function: Integer
    begin
      Sleep(600);
      Result := INTVAL2;
    end;

  FSvFuture.Assign(func1);
  Check(sw.ElapsedMilliseconds < 500, '1');
  CheckEquals(INTVAL, FSvFuture, '2');
  sw.Stop;
  Check(sw.ElapsedMilliseconds >= 1000, '3');

  sw := TStopwatch.StartNew;

  FSvFuture.Assign(func2);

  CheckEquals(INTVAL2, FSvFuture, '4');
  sw.Stop;
  Check(sw.ElapsedMilliseconds >= 500, '5');
end;

{ TestTSvParallel }

procedure TestTSvParallel.SetUp;
begin
  inherited;

end;

procedure TestTSvParallel.TearDown;
begin
  inherited;

end;

procedure TestTSvParallel.TestAsync;
var
  vFlag, vFlag2, vFlag3, vFlag4: Boolean;
  vThr: TSvAsyncThread;
begin
  vFlag := False;
  vFlag2 := False;
  vFlag3 := False;
  vFlag4 := False;
  TSvParallel.SyncFinishEvents := False;
  vThr := TSvParallel.Async(
    procedure
    begin
      vThr.NameThreadForDebugging('asyncThread');
      if not vThr.CheckTerminated then
      begin
        Sleep(50);
        vFlag := True;
      end;
    end,
    procedure
    begin
      vFlag3 := True;
    end);

  TSvParallel.Async(
    procedure
    begin
      Sleep(50);
      vFlag2 := True;
    end,
    procedure
    begin
      vFlag4 := True;
    end);
  Sleep(250);
  CheckTrue(vFlag);
  CheckTrue(vFlag2);
  CheckTrue(vFlag3);
  CheckTrue(vFlag4);
end;

procedure TestTSvParallel.TestForEach;
var
  AFrom, ATo: NativeInt;
  iCounter: Integer;
  AFunc1: TParallelProc1;
  AFunc2 : TParallelProc2;
  vFlag: Boolean;
begin
  TSvParallel.MaxThreads := 10;
  AFrom := 0;
  ATo := 1000 - 1;
  iCounter := 0;
  AFunc1 := procedure(const i: NativeInt; var Abort: Boolean)
    begin
      TInterlocked.Increment(iCounter);
      //Sleep(5);
    end;
  AFunc2 := procedure(const i, AThreadIndex: NativeInt; var Abort: Boolean)
    begin
      Abort := iCounter >= 500;
      if not Abort then
        TInterlocked.Increment(iCounter);

      Sleep(5);
    end;
  TSvParallel.ForEach(AFrom, ATo, AFunc1, nil);
  CheckEquals(ATo + 1, iCounter, '1');
  iCounter := 0;
  TSvParallel.ForEach(AFrom, ATo, AFunc2, nil);
  CheckEquals(500, iCounter, '2');
  iCounter := 0;
  vFlag := False;

  TSvParallel.ForEachNonBlocking(AFrom, ATo, AFunc2,
    procedure
    begin
      vFlag := True;
    end);
  Sleep(1000);
  CheckEquals(500, iCounter, '3');
  CheckTrue(vFlag, '4');
end;
{$HINTS ON}
initialization
  // Register any test cases with the test runner
  RegisterTest(TRepeatedTest.Create(TestTSvFuture.Suite, 1));
  RegisterTest(TRepeatedTest.Create(TestTSvParallel.Suite, 1));
end.

